import ProductBatch from "../models/productBatch.model.js";
import ChainEvent from "../models/chainEvent.model.js";
import Payment from "../models/payment.model.js";
import Farmer from "../models/farmer.model.js";
import Supplier from "../models/supplier.model.js";
import Industry from "../models/industry.model.js";
import { generateQRCode, generateQRURL } from "../utils/qrCodeService.js";

// ==================== FARMER CREATES BATCH ====================

/**
 * Farmer creates a new product batch
 * POST /api/v1/batches/create
 */
export const createBatch = async (req, res) => {
    try {
        const {
            farmerId,
            herbName,
            scientificName,
            category,
            harvestDate,
            quantity,
            gpsCoordinates,
            location,
            qualityMetrics,
            images,
            description,
            farmerPrice,
        } = req.body;

        // Validate farmer exists
        const farmer = await Farmer.findById(farmerId);
        if (!farmer) {
            return res.status(404).json({
                success: false,
                message: "Farmer not found",
            });
        }

        // Approval check removed for testing purposes
        // In production, uncomment the check below:
        // if (!farmer.isApproved) {
        //     return res.status(403).json({
        //         success: false,
        //         message: "Farmer account is not approved yet",
        //     });
        // }

        // Create batch (batchId auto-generated by schema default)
        console.log('ðŸ” Creating batch for farmer:', farmerId);

        const batch = new ProductBatch({
            farmerId,
            herbName,
            scientificName,
            category,
            harvestDate,
            quantity,
            gpsCoordinates,
            location,
            qualityMetrics,
            images,
            description,
            farmerPrice,
            currentOwner: {
                ownerId: farmerId,
                ownerType: "Farmer",
                acquiredAt: new Date(),
            },
            status: "harvested",
        });

        console.log('ðŸ” Batch object created, batchId:', batch.batchId);

        // Generate QR code
        const qrCodeURL = generateQRURL(batch._id, "batch");
        const qrCodeData = await generateQRCode(batch._id, "batch");

        batch.qrCodeURL = qrCodeURL;
        batch.qrCodeData = qrCodeData;

        console.log('ðŸ” About to save batch...');
        await batch.save();
        console.log('âœ… Batch saved successfully with ID:', batch.batchId);

        // Create initial chain event
        const chainEvent = new ChainEvent({
            batchId: batch._id,
            eventType: "BatchCreated",
            performedBy: {
                userId: farmerId,
                userType: "Farmer",
                userName: farmer.name,
                userPhone: farmer.phone,
            },
            location: {
                gpsCoordinates,
                address: `${location.village}, ${location.district}, ${location.state}`,
            },
            metadata: {
                herbName,
                quantity,
                harvestDate,
            },
            timestamp: new Date(),
        });

        await chainEvent.save();

        // Add chain event to batch
        batch.chainEvents.push(chainEvent._id);
        await batch.save();

        res.status(201).json({
            success: true,
            message: "Batch created successfully",
            data: {
                batch,
                qrCodeURL,
                qrCodeData,
            },
        });
    } catch (error) {
        console.error("Create batch error:", error);
        res.status(500).json({
            success: false,
            message: error.message || "Failed to create batch",
        });
    }
};

// ==================== SCAN QR CODE ====================

/**
 * Scan QR code and get complete batch details with chain history
 * GET /api/v1/batches/scan/:batchId
 */
export const scanBatch = async (req, res) => {
    try {
        const { batchId } = req.params;
        const { scannedBy, scannerType } = req.query; // Optional: track who scanned

        // Find batch and populate references
        const batch = await ProductBatch.findById(batchId)
            .populate("farmerId", "name phone profileImage address")
            .populate({
                path: "chainEvents",
                options: { sort: { timestamp: 1 } },
            })
            .populate("finalProduct");

        if (!batch) {
            return res.status(404).json({
                success: false,
                message: "Batch not found",
            });
        }

        // Get current owner details
        let currentOwnerDetails = null;
        if (batch.currentOwner.ownerType === "Farmer") {
            currentOwnerDetails = await Farmer.findById(batch.currentOwner.ownerId).select(
                "name phone profileImage address"
            );
        } else if (batch.currentOwner.ownerType === "Supplier") {
            currentOwnerDetails = await Supplier.findById(batch.currentOwner.ownerId).select(
                "name phone profileImage rating"
            );
        } else if (batch.currentOwner.ownerType === "Industry") {
            currentOwnerDetails = await Industry.findById(batch.currentOwner.ownerId).select(
                "industryName phone companyLogo email"
            );
        }

        // Build complete chain with user details
        const completeChain = await Promise.all(
            batch.chainEvents.map(async (event) => {
                let performerDetails = null;

                if (event.performedBy.userType === "Farmer") {
                    performerDetails = await Farmer.findById(event.performedBy.userId).select(
                        "name phone profileImage"
                    );
                } else if (event.performedBy.userType === "Supplier") {
                    performerDetails = await Supplier.findById(event.performedBy.userId).select(
                        "name phone profileImage"
                    );
                } else if (event.performedBy.userType === "Industry") {
                    performerDetails = await Industry.findById(event.performedBy.userId).select(
                        "industryName phone companyLogo"
                    );
                }

                return {
                    ...event.toObject(),
                    performerDetails,
                };
            })
        );

        // Track consumer scans
        if (scannedBy && scannerType === "Consumer") {
            const scanEvent = new ChainEvent({
                batchId: batch._id,
                eventType: "ConsumerScan",
                performedBy: {
                    userId: scannedBy,
                    userType: "Consumer",
                },
                timestamp: new Date(),
            });
            await scanEvent.save();
        }

        res.status(200).json({
            success: true,
            data: {
                batch: {
                    ...batch.toObject(),
                    currentOwnerDetails,
                },
                chainHistory: completeChain,
                totalEvents: completeChain.length,
            },
        });
    } catch (error) {
        console.error("Scan batch error:", error);
        res.status(500).json({
            success: false,
            message: error.message || "Failed to scan batch",
        });
    }
};

// ==================== GET FARMER'S BATCHES ====================

/**
 * Get all batches created by a farmer
 * GET /api/v1/batches/farmer/:farmerId
 */
export const getFarmerBatches = async (req, res) => {
    try {
        const { farmerId } = req.params;
        const { status, page = 1, limit = 10 } = req.query;

        const query = { farmerId };
        if (status) {
            query.status = status;
        }

        const batches = await ProductBatch.find(query)
            .sort({ createdAt: -1 })
            .limit(limit * 1)
            .skip((page - 1) * limit)
            .populate("chainEvents");

        const total = await ProductBatch.countDocuments(query);

        res.status(200).json({
            success: true,
            data: {
                batches,
                totalPages: Math.ceil(total / limit),
                currentPage: page,
                total,
            },
        });
    } catch (error) {
        console.error("Get farmer batches error:", error);
        res.status(500).json({
            success: false,
            message: error.message || "Failed to fetch batches",
        });
    }
};

// ==================== GET BATCH BY ID ====================

/**
 * Get single batch details
 * GET /api/v1/batches/:batchId
 */
export const getBatchById = async (req, res) => {
    try {
        const { batchId } = req.params;

        const batch = await ProductBatch.findById(batchId)
            .populate("farmerId", "name phone profileImage address")
            .populate("chainEvents")
            .populate("finalProduct");

        if (!batch) {
            return res.status(404).json({
                success: false,
                message: "Batch not found",
            });
        }

        res.status(200).json({
            success: true,
            data: { batch },
        });
    } catch (error) {
        console.error("Get batch error:", error);
        res.status(500).json({
            success: false,
            message: error.message || "Failed to fetch batch",
        });
    }
};

// ==================== UPDATE BATCH ====================

/**
 * Update batch details (only by current owner)
 * PATCH /api/v1/batches/:batchId
 */
export const updateBatch = async (req, res) => {
    try {
        const { batchId } = req.params;
        const { userId, userType, ...updateData } = req.body;

        const batch = await ProductBatch.findById(batchId);

        if (!batch) {
            return res.status(404).json({
                success: false,
                message: "Batch not found",
            });
        }

        // Verify ownership
        if (
            batch.currentOwner.ownerId.toString() !== userId ||
            batch.currentOwner.ownerType !== userType
        ) {
            return res.status(403).json({
                success: false,
                message: "Only current owner can update batch",
            });
        }

        // Update allowed fields
        Object.keys(updateData).forEach((key) => {
            if (updateData[key] !== undefined) {
                batch[key] = updateData[key];
            }
        });

        await batch.save();

        res.status(200).json({
            success: true,
            message: "Batch updated successfully",
            data: { batch },
        });
    } catch (error) {
        console.error("Update batch error:", error);
        res.status(500).json({
            success: false,
            message: error.message || "Failed to update batch",
        });
    }
};

// ==================== SEARCH BATCHES ====================

/**
 * Search batches by herb name, location, etc.
 * GET /api/v1/batches/search
 */
export const searchBatches = async (req, res) => {
    try {
        const { herbName, district, state, status, page = 1, limit = 10 } = req.query;

        const query = { isActive: true };

        if (herbName) {
            query.herbName = { $regex: herbName, $options: "i" };
        }

        if (district) {
            query["location.district"] = { $regex: district, $options: "i" };
        }

        if (state) {
            query["location.state"] = { $regex: state, $options: "i" };
        }

        if (status) {
            query.status = status;
        }

        const batches = await ProductBatch.find(query)
            .sort({ createdAt: -1 })
            .limit(limit * 1)
            .skip((page - 1) * limit)
            .populate("farmerId", "name phone address");

        const total = await ProductBatch.countDocuments(query);

        res.status(200).json({
            success: true,
            data: {
                batches,
                totalPages: Math.ceil(total / limit),
                currentPage: page,
                total,
            },
        });
    } catch (error) {
        console.error("Search batches error:", error);
        res.status(500).json({
            success: false,
            message: error.message || "Failed to search batches",
        });
    }
};
